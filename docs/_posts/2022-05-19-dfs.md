---
layout: post
title: "O(V + E) Algorithm - Depth-First Search"
date:  2022-05-19 11:11:53 +0800
categories: Algorithm
---

之前我们介绍了[广度优先搜索](https://guo-sj.github.io/algorithm/2022/04/19/bfs.html)
，今天我们来介绍深度优先搜索（Depth-First Search, aka DFS）算法。

这篇文章给出了深度优先搜索的算法描述，并用一个二叉树作为例子，用golang实现一个
深度优先遍历程序。

我们先来描述深度优先搜索算法：
```
       在图中选取一个节点作为根节点，将根节点入栈
               |
               V
   --> 当栈不为空时
  |            |
  |            V
  |    弹出栈顶元素E
  |            |
  |            V
  |    如果E没有搜索过，则判断E是否为目标节点，如果是，程序结束；
  |    如果E已经搜索过，则continue
  |            |
  |            V
  |    将E标记为已经搜索过
  |            |
  |            V
  |    将E所有的邻居节点入栈
  |            |
   ------------
```

我们把上述的算法描述稍稍进行修改，把“栈”改成“对列”，就可以得到之前学过的广度优先搜索的算法
描述：
```
       在图中选取一个节点作为根节点，将根节点入对列
               |
               V
   --> 当对列不为空时
  |            |
  |            V
  |    弹出对列顶元素E
  |            |
  |            V
  |    如果E没有搜索过，则判断E是否为目标节点，如果是，程序结束；
  |    如果E已经搜索过，则continue
  |            |
  |            V
  |    将E标记为已经搜索过
  |            |
  |            V
  |    将E所有的邻居节点入对列
  |            |
   ------------
```

在进行了算法描述之后，我们来看一个二叉树的例子。
```
             A
            / \
           B   C
          / \  / \
         D  E F   G
```
我们知道，树（Tree）是一种特殊的图（Graph），特殊之处在于树是自顶
向下的，没有边会从下面的节点指上来。

对于这个二叉树，如果我们用深度优先遍历，那么输出顺序为：A, B, D, E, C, F, G。 
如果用广度优先遍历，那么输出顺序为：A, B, C, D, E, F, G。

这里是[Golang的实现](https://github.com/guo-sj/algorithm-go/blob/master/binary-tree-bfs-dfs/main.go)。

以上。
